#!/usr/bin/env python3

import os
import re
import sys
from   datetime import datetime
import json
import glob
import argparse
from pathlib import Path
from pprint import pprint
from selenium import webdriver
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support.ui import Select

from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.webdriver.common.alert import Alert
from fabric import Connection
import invoke
import shutil

FILENAMES = {
		'filename_arch16n':'english.0.properties',
		'filename_css':'ui_styling.css',
		'filename_data_schema':'data_schema.xml',
		'filename_ui_logic':'ui_logic.bsh',
		'filename_ui_schema':'ui_schema.xml',
		'filename_validation':'validation.xml'
}

USERNAME = 'faimsadmin@intersect.org.au'
PASSWORD = 'Pass.123'


error_state = False
DEBUG = False

parser = argparse.ArgumentParser(description='Upload autogenerated module to faims server')
parser.add_argument('module_path', nargs='?',type=str, default='module', help="path to module document directory")
parser.add_argument('--config', type=str, default="conf.json", help="location of the config file")
parser.add_argument('--rm', action='store_true', help="remove module(s) with same path name")
parser.add_argument('--replace', action='store_true', help="remove module(s) with same base name and upload new one")
parser.add_argument('--state-string', default='automatic', help="An extra state string in the module name?")
parser.add_argument('--base-url', default='dev26.fedarch.org', help="Which server to use? Do not include protocol (http://)")
parser.add_argument('--only-maps', action='store_true', help="Only upload maps")
args = parser.parse_args()
BASE_URL    = args.base_url
# Make sure all specification files are in the path'd directory
module_location = Path(os.getcwd()) / args.module_path

for file in FILENAMES:
	if (module_location / FILENAMES[file]).is_file():
		FILENAMES[file] = module_location / FILENAMES[file]
	else:
		raise FileNotFoundError(module_location / FILENAMES[file])




try:
	with open('conf.json', 'r') as confjson:
		jsondata = json.load(confjson)
		module_name = jsondata['module_name']
		module_srid = jsondata['SRID']
		print("Jsondata found:",jsondata)

except:
	print("Making default conf file")
	moduleParts = module_location.parts
	moduleJsonData = {'module_name':module_name, 'srid': 4326}
	module_srid = 4326
	if moduleParts[-1] == 'module': 
		module_name = str(moduleParts[-2])
		with open(module_location / '..' / 'conf.json', 'w') as confjson:
			json.dump( moduleJsonData, confjson)
	else:                          
		module_name = str(moduleParts[-1])
		with open(module_location / 'conf.json', 'w') as confjson:
			json.dump(moduleJsonData, confjson)



print("Working on module with the name \"{}\"...".format(module_name))   




def login(driver, baseurl, username, password):
	driver.get("http://{}".format(baseurl))
	element = WebDriverWait(driver, 10).until(
			EC.element_to_be_clickable((By.XPATH, "//form"))
	)
	username_element = driver.find_element_by_name("user[email]" )
	username_element.send_keys(username)
	password_element = driver.find_element_by_name("user[password]" )
	password_element.send_keys(password)
	element = driver.find_element_by_xpath("//input[@name='commit']")
	element.click()

def addFile(driver, file_path, field_name):
	element = driver.find_element_by_xpath("//input[@name='{}']".format(field_name) )
	element.send_keys(str(file_path))


def upload_data(driver, module_name, args):
	# driver.get("http://{}/project_modules".format(baseurl))

	tarballs = glob.glob('**/data*.tar.gz')
	if len(tarballs) > 1:
		raise ValueError("Too many data tarballs!")
	elif len(tarballs) == 0:
		print("No data tarball found, skipping upload.")
		return
	tarballpath = tarballs[0]
	
	tarballname = os.path.split(tarballpath)[-1]

	element = WebDriverWait(driver, 1).until(
				EC.element_to_be_clickable((By.XPATH, "//a[contains(text(), '{} {}')]".format(module_name, args.state_string)))
		)
	element.click()
	print("Uploading files...")
	element = WebDriverWait(driver, 3).until(
			EC.element_to_be_clickable((By.XPATH, "//a[contains(text(), 'Upload Files')]"))
	)
	element.click()
	print("Choose file...")
	element = driver.find_element_by_xpath("//input[@name='project_module[file]']")
	element.send_keys(str(Path(os.getcwd()) / tarballpath))
	element = driver.find_element_by_xpath("//input[@name='commit']")
	element.click()
	alert = driver.switch_to.alert
	alert.accept()
	alerts = driver.find_elements_by_class_name('alert-success')
	errors = driver.find_elements_by_class_name('alert-error')
	responses = driver.find_elements_by_class_name('help-inline')

	for alert in alerts:
		print("Success: {}".format(alert.text).replace("×\n", ""))
	for alert in errors:
		print("Alert Error: {}".format(alert.text).replace("×\n", ""))
	for response in responses:
		print("Error: {}".format(response.text).replace("×\n", ""))
		raise ValueError("Error in module upload.")

def upload_module(driver, module_name, filenames,args, do_upload_data_schema=False):
	try:
		if do_upload_data_schema:
			raise Exception
			# We just need to go do stuff in the except block, I guess?
		#print("//a[contains(text(), '{} {}')]".format(module_name, args.state_string))		
		element = WebDriverWait(driver, 1).until(
				EC.element_to_be_clickable((By.XPATH, "//a[contains(text(), '{} {}')]".format(module_name, args.state_string)))
		)
		element.click()
		print("Editing module...")
		element = WebDriverWait(driver, 3).until(
				EC.element_to_be_clickable((By.XPATH, "//a[contains(text(), 'Edit Module')]"))
		)
		element.click()
		
	except:	
		print("Creating new module")
		element = WebDriverWait(driver, 10).until(
				EC.element_to_be_clickable((By.XPATH, "//a[@href='/project_modules/new']"))
		)
		element.click()
		do_upload_data_schema=True
	

	form_element = WebDriverWait(driver, 10).until(
			EC.element_to_be_clickable((By.XPATH, "//form"))
	)
	element = driver.find_element_by_xpath("//input[@name='project_module[name]']" )
	#module_name += datetime.now().strftime(' {} %Y-%m-%d'.format(args.state_string))
	element.clear()
	local_module_name= "{} {} {}".format(module_name, args.state_string, datetime.now().strftime('%Y-%m-%d'))
	element.send_keys(local_module_name)
	select = Select(driver.find_element_by_id('project_module_srid'))
	print("Applying SRID: {}".format(module_srid))
	select.select_by_value(str(module_srid))
	
	element = driver.find_element_by_xpath("//input[@name='project_module[version]']" )
	element.clear()
	element.send_keys(str(datetime.now()))

	addFile(driver, filenames['filename_arch16n']    		, 'project_module[arch16n]')
	addFile(driver, filenames['filename_css']        		, 'project_module[css_style]')
	if do_upload_data_schema:
		addFile(driver, filenames['filename_data_schema'] 	, 'project_module[data_schema]')
	addFile(driver, filenames['filename_ui_logic']    		, 'project_module[ui_logic]')
	addFile(driver, filenames['filename_ui_schema']   		, 'project_module[ui_schema]')
	addFile(driver, filenames['filename_validation'] 		, 'project_module[validation_schema]')

	# https://stackoverflow.com/a/17530571/263449
	element.submit()

	element = WebDriverWait(driver, 2).until(
        EC.presence_of_element_located((By.CLASS_NAME, "alert"))
    )
	alerts = driver.find_elements_by_class_name('alert-success')
	errors = driver.find_elements_by_class_name('alert-error')
	responses = driver.find_elements_by_class_name('help-inline')
	for alert in alerts:
		print("Success: {}".format(alert.text).replace("×\n", ""))
	for alert in errors:
		print("Alert Error: {}".format(alert.text).replace("×\n", ""))
	for response in responses:
		print("Error: {}".format(response.text).replace("×\n", ""))
		raise ValueError("Error in module upload.")
	
#chrome_options = webdriver.ChromeOptions()
#chrome_options.add_experimental_option('prefs', profile)
#driver = webdriver.Chrome(options=chrome_options)

""" remove_module.sh
#!/bin/bash -l

cd /var/www/faims
rake modules:wipe key="$1"

"""

def delete_module(module_name, base_url, args):
	with Connection(base_url) as conn:
		module_search = module_name
		if args.state_string:
			module_search = "{} {}".format(module_name, args.state_string)

		try:
			result = conn.run('grep -r --include "*module.settings" "{}" /var/www/faims/modules/'.format(module_search), hide=True)
			for line in result.stdout.split("\n"):
				if DEBUG:
					print(line)
				research = re.search(r"(\{.*\})", line)
				if research:
					jsonline = json.loads(research.group(1))
					print("Deleting: {}".format(jsonline['key']))
					
					conn.run("bash /home/ubuntu/remove_module.sh \"{}\"".format(jsonline['key']))
		except invoke.exceptions.UnexpectedExit:
			print("No prior modules found")
		#msg = "Ran {0.command!r} on {0.connection.host}, got stdout:\n{0.stdout}"
		#print(msg.format(result))



driver = webdriver.Chrome()

try:
	if args.rm or args.replace:
		delete_module(module_name, BASE_URL, args)
	if not args.rm and not args.only_maps:

		login(driver, BASE_URL, USERNAME, PASSWORD)
		upload_module(driver, module_name, FILENAMES, args)
		driver.get("http://{}/project_modules".format(BASE_URL))
		upload_data(driver, module_name, args)
	if args.only_maps:
		
		upload_data(driver, module_name, args)
		
finally:
	if not DEBUG:
		driver.quit()
