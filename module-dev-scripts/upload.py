#!/usr/bin/env python3

# from   mimetypes import MimeTypes
# import cookielib
import mechanicalsoup #from mechanize since that's python2
import os
import re
import sys
# import urllib
# import urllib2
from   datetime import datetime
import json
import glob
import argparse
from pathlib import Path
from pprint import pprint
################################################################################

filenameArch16n    = 'english.0.properties'
filenameCss        = 'ui_styling.css'
filenameDataSchema = 'data_schema.xml'
filenameUiLogic    = 'ui_logic.bsh'
filenameUiSchema   = 'ui_schema.xml'
filenameValidation = 'validation.xml'

filenames = [
        filenameArch16n,
        filenameCss,
        filenameDataSchema,
        filenameUiLogic,
        filenameUiSchema,
        filenameValidation
]

username = 'faimsadmin@intersect.org.au'
password = 'Pass.123'

server = 'dev26'
url    = 'http://{}.fedarch.org'.format(server)

################################################################################
doDelete  = False
doReplace = False
hasFlag   = False


parser = argparse.ArgumentParser(description='Upload autogenerated module to faims server')
parser.add_argument('module_path', nargs='?',type=str, default='module', help="path to module document directory")
parser.add_argument('--config', type=str, default="conf.json", help="location of the config file")
parser.add_argument('--rm', action='store_true', help="remove module(s) with same path name")
parser.add_argument('--replace', action='store_true', help="remove module(s) with same base name and upload new one")


args = parser.parse_args()
# Make sure all specification files are in the path'd directory
moduleLocation = Path(os.getcwd()) / args.module_path

for file in filenames:
    if not (moduleLocation / file).is_file():
        raise FileNotFoundError(moduleLocation / file)

if args.rm:
    doDelete = True

if args.replace:
    doReplace = True


# Determine module name using a heuristic. If the module is in a (parent)
# directory called 'module', it's generally reasonable to assume that
# directory was created by the autogen. In that case, the name of the
# grandparent directory is probably a more apt name for the module. (Though this
# heuristic could fail in a ridiculous way.)
try:
    with open('conf.json', 'r') as confjson:
        moduleName = json.load(confjson)['moduleName']

except:
    moduleParts = moduleLocation.parts
    
    if moduleParts[-1] == 'module': 
        moduleName = str(moduleParts[-2])
        with open(moduleLocation / '..' / 'conf.json', 'w') as confjson:
            json.dump( {'moduleName':moduleName}, confjson)
    else:                          
        moduleName = str(moduleParts[-1])
        with open(moduleLocation / 'conf.json', 'w') as confjson:
            json.dump({'moduleName':moduleName}, confjson)

originalModuleName = moduleName
moduleName += datetime.now().strftime(' %Y-%m-%d')


print("Working on module with the name \"{}\"...".format(moduleName))
# Initialisation of `magic` python module
# mime = MimeTypes()
# mime.add_type('text/plain', '.bsh')
# mime.add_type('text/plain', '.properties')

################################################################################

def addFile(form, filename, inputName):
    if not filename: 
        return
    fullFilename = moduleLocation / filename
    #mimetype     = mime.guess_type(filename)
    #mimetype     = mimetype[0]
    print(inputName, fullFilename)

    form[inputName] = str(moduleLocation / filename)

def addFiles(form, doUploadDataSchema):
    
    addFile    (form, filenameArch16n    , 'project_module[arch16n]')
    addFile    (form, filenameCss        , 'project_module[css_style]')
    if doUploadDataSchema:
        addFile(form, filenameDataSchema , 'project_module[data_schema]')
    addFile    (form, filenameUiLogic    , 'project_module[ui_logic]')
    addFile    (form, filenameUiSchema   , 'project_module[ui_schema]')
    addFile    (form, filenameValidation , 'project_module[validation_schema]')

def login(browser, username, password, url):
    
    # Get login form and fill it out
    
    res = browser.open(url)
    print("Logging in... ", end="")

    browser.select_form("form[action='/users/sign_in']")
    browser['user[email]']    = username
    browser['user[password]'] = password

    # Submit yer good ol' form
    print('Submitting login form... ', end="")
    
    res = browser.submit_selected()
    if res.ok:
        print("Logged in!")
    else:
        # https://2.python-requests.org//en/master/api/#requests.Response
        res.raise_for_status()

def goHome(browser, url):
    

    browser.open(url)

def deleteModule(browser):
    print('Downloading delete form...')
    # Try clicking on link to module config page
    try:
        linkText = '^%s' % originalModuleName
        res      = browser.follow_link(link_text=linkText)
    except:
        print('Cannot delete module; does not exist. Exiting.')
        return

    # Get URL to delete module
    linkText = 'Delete Module'
    req      = browser.click_link(link=linkText)
    url      = req.get_full_url()

    # Search for the stupid CSRF token
    token    = res.get_data()
    token    = re.search('"([^"]+)"\s+name="csrf-token"', token)
    token    = token.group(1)
    params   = {
            u'_method'            : 'delete',
            u'authenticity_token' : token
    }
    data = urllib.urlencode(params)

    # POST the deletion request
    try:
        browser.open(url, data)
        print('All done!')
    except:
        print('Cannot delete module. Exiting.')

def uploadModule(browser, moduleName):
    # Determine if module's already been uploaded. 
    print('Downloading update/create form... ', end="")

    #print(browser.find_link(url_regex='project_modules/new'))

    try:
        # The module's already been uploaded
        print('Looking for ^{}$... '.format(moduleName), end="")
        linkText = r'^{}$'.format(moduleName)
        res      = browser.follow_link(link_text=linkText)

        linkText = 'Edit Module'
        res      = browser.follow_link(link_text=linkText)

        print('Submitting update form...')
        
        browser.select_form(nr=0)
        addFiles(browser, doUploadDataSchema=False)
        res = browser.submit()
    except:
        print("\nNo module found, creating... ", end="")
        # We need to create a new module
        link_text = r' Create Module' # There's a space in the text in the link
        res      = browser.follow_link(link_text=link_text)
        # print(res)
        # print(browser.get_url())
        print('Submitting create form... ')
        
        browser.launch_browser()
        form = browser.select_form("form[action='/project_modules']")
        form.print_summary()
        form['project_module[name]'] = moduleName
        addFiles(form, doUploadDataSchema=True)
        res = browser.submit(form)
        soup = browser.get_current_page()
        #print(soup)

        errors = soup.find_all('span.help-inline')
        for error in errors:
            print(error)
        # reg = '<span class="help-inline">([^<]+)</span>'
        # doesMatch = re.search(reg, res)
        # Ms = re.finditer(reg, res)
        # if not doesMatch:
        #     print('All done!')
        #     return
        # print('Completed with errors:')
        # for m in Ms:
        #     print('  - ', m.group(1))


################################################################################
# Make browser
browser = mechanicalsoup.StatefulBrowser()
browser.set_debug(True)
browser.set_verbose(2)
# # Initialisation of `mechanize` module (Some stuff I copied from Stack Overflow)
# cookiejar = cookielib.LWPCookieJar()
# browser.set_cookiejar      (cookiejar)
# browser.set_handle_equiv   (True)
# browser.set_handle_gzip    (True)
# browser.set_handle_redirect(True)
# browser.set_handle_referer (True)
# browser.set_handle_robots  (False)

# Navigate website and upload module
login(browser, username, password, url)
if doReplace:
    deleteModule(browser)
    goHome      (browser, url)
    uploadModule(browser, moduleName)
elif doDelete:
    deleteModule(browser)
else:
    uploadModule(browser, moduleName)
