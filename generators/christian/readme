QUICK START

  1. Modify the example module.xml. If you see something there which you don't
     understand, check this file.
  2. Run `./generate.sh`. (You can also run `./generate.sh /path/to/module.xml`
     if your module.xml is somewhere other than the root directory.)
  3. Collect your new shiny new module from the 'module' directory and your
     shiny new wireframe from the 'wireframe' directory.
________________________________________________________________________________

ATTRIBUTES

  b                  Binding (See 'Bindings')
  c                  Alias for faims_style_class
  e="Type"           Populates the menu with entities of the type `Type`. If the
                    `Type` is the empty string, entities of all types are shown.
  ec, lc             (See 'Child Entities'.)
  f                  Flags (See 'Flags')
  l                  Link to tab or tab group in the format Tabgroup/Tab/. Links
                     to tabs are discouraged as the generated code will contain
                     a race condition. Autogenerated code containing tab links
                     should be thoroughly tested.
  p                  In <opt> tags, equivalent to pictureURL attribute, however
                     "files/data/" is prepended.
  suppressWarnings   Prevents warnings from being shown when equal to "true" and
                     present in the <module> tag. Does not suppress errors.
  t                  Type of GUI element (See 'Types'). If this attribute is
                     omitted, the autogenerator will attempt to infer it from
                     the element's content. (See 'Type Guessing'.)
________________________________________________________________________________

BINDINGS

  - date
  - decimal
  - string
  - time
  Other bindings are possible (e.g. by writing b = "my-binding") but generate a
  warning.
________________________________________________________________________________

FLAGS

  autonum         For use with <autonum> tag. (See 'Autonumbering'.)
  hidden          Equivalent to faims_hidden="true".
  id              Equivalent to isIdentifier="true".
  noannotation    Equivalent to faims_annotation="false".
  nocertainty     Equivalent to faims_certainty="false".
  nolabel         Prevents labels from being displayed or generated from element
                  names.
  nosync          Removes the faims_sync="true" attribute from audio, camera,
                  file and video GUI elements.
  nothumb[nail]   Removes the thumbnail="true" attribute from audio, camera,
                  file and video elements in the data schema.
  noscroll        Equivalent to faims_scrollable="false".
  noui            Only allows code related to the data schema to be generated.
  nodata          Generates code as usual, but ommits data schema entries.
  readonly        Equivalent to faims_read_only="true".
  user            Used to indicate that a menu should contain a list of users.
  notnull         Adds client- and server-side validation specifying that the
                  field should not be left blank.
________________________________________________________________________________

TYPE GUESSING

  The autogenerator will attempt to make a reasonable assumption about what the
  t attribute should be set to if it is omitted from a GUI element's set of XML
  tags.

  If the XML tags do not contain a set of <opts> tags nor the f="user" flag,
  t="input" is assumed. Example:

      <Entity_Identifier f="id"/>          <!-- This'll be an input -->

  If the XML tag is flagged with f="user", t="list" is assumed. Example:

      <List_of_Users f="user"/>            <!-- This'll be a list -->

  If the XML tags contain an <opts> element and no descendants with p
  attributes, t="dropdown" is assumed. Example:

      <Element>                            <!-- This'll be a dropdown -->
        <opts>
          <opt>Option 1</opt>
          <opt>Option 2</opt>
        </opts>
      </Element>

  If the XML tags contain an <opts> element and one or more descendants with p
  attributes, t="picture" is assumed. Example:

      <Element>                            <!-- This'll be a picture gallery -->
        <opts>
          <opt p="Lovely_Image.jpg>Option 1</opt>
          <opt                    >Option 2</opt>
        </opts>
      </Element>
________________________________________________________________________________

TYPES

  Types of GUI element:
    - audio        A button which allows audio to be recorded upon being tapped.
                   Recorded audio is saved to the tab group the button appears
                   in.
    - button       A button. By default, this does not perform any action. A
                   common method of associating buttons with actions is to link
                   them to other tabs or tab groups using the `l` or `lc`
                   attributes. (See 'Attributes'.)
    - camera       A button which allows photographs to be taken upon being
                   tapped. Recorded photographs are saved to the tab group the
                   button appears in. (Search terms: images, photos, pictures.)
    - checkbox     A group of checkboxes. Options are specified using the <opts>
                   tags.
    - dropdown     A dropdown menu. Options are specified using the <opts> tags.
    - file         A button which allows files to be attached upon being tapped.
                   attached files are saved to the tab group the button appears
                   in.
    - gpsdiag      A read-only text field containing GPS diagnostic information.
    - group        Produces a <group> element in the generated UI schema. See
                   the "FAIMS Data, UI and Logic Cook-Book" for more information
                   on the <group> element.
    - input        A text field.
    - list         A list. Entries are specified using the <opts> tags.
    - map          A map interface. Map data must be manually added to the
                   module by modifying the generated UI logic file.
    - picture      A picture gallery. This is a kind of menu (like a dropdown or
                   list), whose options have images which are displayed to the
                   user. Options are specified with the <opts> tags. Images are
                   specified using `p`. (See 'Attributes'.)
    - radio        A group of radio buttons. (Also sometimes called "option
                   buttons".) Options are specified using the <opts> tags.
    - video        A button which allows videos to be recorded upon being
                   tapped. Recorded videos are saved to the tab group the button
                   appears in.
    - viewfiles    A button to view all files related to a tab group.
    - web[view]    A viewport which allows the rendering of HTML. HTML must be
                   manually added to the module by modifying the generated UI
                   logic file. See the "FAIMS Data, UI and Logic Cook-Book" for
                   more information on web views and how they are populated.
________________________________________________________________________________

RESERVED ELEMENT NAMES AND RECOMMENDED NAMING CONVENTIONS

  "Reserved" elements only contain lowercase letters:
    - <autonum>    A group of fields containing the next ID's of the inputs
                   marked with f="autonum".  (See 'Autonumbering'.)
    - <col>        One column in a <cols> tag
    - <cols>       Columns
    - <desc>       Description to put in the data schema
    - <logic>      UI logic which is appened to end of generated file.
    - <module>
    - <opt>        Option in <opts> tag
    - <opts>       Options for, say, a dropdown menu
    - <rels>       Intended to be a direct child of <module> and hold
                   <RelationshipElement> tags
    - <gps>        A set of fields including Latitude, Longitude, Northing,
                   Easting and a "Take From GPS" button.
    - <search>     A tab for searching all records. Its text is used as a label.
    - <str>        Contains <formatString>-related data.
    - <pos>        When the child of a <str>, gives the position (order) of an
                   identifier in a formatted string
    - <fmt>        When the child of a <str>, contains <formatString> data.
    - <app>        When the child of a <str>, contains <appendCharacterString>
                   data.
    - <author>     A read-only field displaying the username of the current user
                   or a message if the entity it appears in has not been saved.
    - <timestamp>  A read-only field displaying the creation time of the entity
                   it appears in.
  User-defined elements should start with an uppercase letter and use
  underscores as separators:
    - <My_User_Defined_Element t="dropdown" />
  Neither of these naming conventions are strictly enforced however.
________________________________________________________________________________

INTENDED PURPOSE OF THE <rels> TAG

  When placed as a direct child of the <module> element, contents of the <rels>
  tag are copied as-is to the generated data schema. No warnings are shown if
  something is awry with its contents.

  Because the <rels> tags' contents are directly copied, in principle you could
  put anything in there which you want to appear in the data schema. Doing so
  would make you a bad person.
________________________________________________________________________________

SEMANTICS OF <cols> TAGS

  Direct children of <cols> tags are interpreted as columns. For example,
      <cols>
        <Field_1 t="input"/>
        <Field_2 t="input"/>
        <Field_3 t="input"/>
      </cols>
  has three columns, each containing an input. The left-most column is Field_1,
  whereas the right-most is Field_3.

  When a <col> tag is a direct child, its contents are interpreted as being part
  of a distinct column. Therefore,
      <cols>
        <Field_1 t="input"/>
        <col>
          <Field_2 t="input"/>
          <Field_3 t="input"/>
        </col>
      </cols>
  results in two columns. The left column contains Field_1, while the right
  contains Field_2 and Field_3.
________________________________________________________________________________

AUTONUMBERING

  Basic autonumbering can be achieved using a combination of the f="autonum"
  flag and the <autonum/> tag. By flagging an input with `autonum`, one
  indicates to the autogenerator that the ID of the next created entity---the
  entity containing the flagged field---should be taken from the corresponding
  field generated using the <autonum/> tag. For instance the Creatively_Named_ID
  in the below module will take its values from a field in Control which is
  generated by the use of the <autonum/> tag.
      <module>
        <Control>
          <Control>
            <Create_Entity t="button" l="Tab_Group" />
            <autonum/>
          </Control>
        </Control>
        <Tab_Group>
          <Tab>
            <Creatively_Named_ID f="id autonum" />
          </Tab>
        </Tab_Group>
      </module>
  The field will appear to the user as "Next Creatively Named ID" and will
  initially be populated with the number 1. When the user creates a Tab_Group
  entity, it will take that number as its "Creatively Named ID". The "Next
  Creatively Named ID" will then be incremented to 2, ready to be copied when
  a subsequent Tab_Group entity is created.

  Multiple fields can be flagged as being autonumbered like so:
      <module>
        <Control>
          <Control>
            <Create_Entity t="button" l="Tab_Group" />
            <autonum/>
          </Control>
        </Control>
        <Tab_Group>
          <Tab>
            <Creatively_Named_ID   f="id autonum" />
            <Creatively_Named_ID_2 f="id autonum" />
          </Tab>
        </Tab_Group>
        <Other_Tab_Group>
          <Tab>
            <Creatively_Named_ID_3 f="id autonum" />
          </Tab>
        </Other_Tab_Group>
      </module>

________________________________________________________________________________

CHILD ENTITIES

  Entities can be saved as children by the use of the "lc" attribute. For
  instance, writing
      <Add_Child t="button" lc="Child_Ent" />
  generates a button which links to the Child_Ent tab group. When displayed by
  clicking the Add_Child button, the Child_Ent tab group will have auto-saving
  enabled and be saved as a child of the tab group that the button appeared in.
  For example, consider the following module.xml:
      <module>
        <Tab_Group>
          <Tab>
            <Add_Child t="button" lc="Tab_Group" />
          </Tab>
        </Tab_Group>
      </module>
  Clicking the Add_Child button will cause the user to be taken to a new
  instance of Tab_Group which will be saved as a child of the original instance.
  But because the original instance was not loaded by clicking the button, it
  will not be saved as a child.

  A list of child entities can be displayed to the user by using the "ec"
  attribute:
      <List_Of_Related_Entities t="list" ec="Type_Of_Childen" />
  The list will be populated with entities which are children of the tab group
  the list appears in. The entities will be constrained to have the type
  "Type_Of_Children". However, writing `ec=""` produces an unconstrained list,
  where children of all types are displayed.

  The user should note carefully that, while including an "lc" attribute causes
  a corresponding <RelationshipElement> to be generated in the data schema,
  including an "ec" attribute does not.
________________________________________________________________________________

LABELS

  An element's text is taken as its label. For instance, the following input
      <My_Input t="input">
        Droopy Soup
        <desc>Similar to drippy soup, but not quite...</desc>
      </My_Input>
  has the label "Droopy Soup". Note that following and preceding whitespace is
  stripped.

  If a label is not provided, it is "inferred" from the element's name. More
  specifically, underscores in the element's name are replaced with spaces,
  which becomes the element's label. Therefore, the element
      <Droopy_Soup t="input">
        <desc>Similar to drippy soup, but not quite...</desc>
      </Droopy_Soup>
  has the same label as in the above example. Thus, the user will see exactly
  the same thing in both cases. However, their representations in the data and
  UI schemas, and the arch16n file will be different.

  You are recommended to use this "inference" feature, as it encourages
  consistency between the label, which the user sees, and the view's reference
  and faims_attribute_name, which the programmer sees. Note that it merely
  "encourages" consistency as the programmer can change the corresponding,
  generated, arch16n (english.0.properties) entry.
________________________________________________________________________________

GENERATION OF THE ARCH16N FILE

  Labels and menu options (e.g. from checkboxes and dropdowns) have arch16n
  entries generated for them. The left-hand side of an arch16n entry (i.e.
  everything to the left of the equals sign) is produced by changing all
  non-alphanumeric characters in the label or menu option to underscores. The
  right-hand side is the unmodified text.

  The created arch16n entries are used in the generated UI and data schemas.

  It should be carefully noted that replacing characters as described above can
  cause naming conflicts. For example, if the module.xml file contains the
  labels "I'm cool!" and "I'm cool?", the generated arch16n file will contain
  the following lines:
      I_m_cool_=I'm cool!
      I_m_cool_=I'm cool?
  Moreover, the programmer is not warned if such a conflict exists, as, in
  practise, it assumed that such conflicts are very rare and checking for them
  in XSLT 1.0 violates Article 5 of 'The Universal Declaration of Human Rights'.
________________________________________________________________________________

KNOWN ISSUES

  Arbitrarily nested group elements cannot be specified within a tab. For
  example, the code generated from the following module.xml is undefined:
      <?xml version="1.0" ?>
      <module>
        <Tab_Group>
          <Tab>
            <Field_1 t="group">
              <Field_2 t="group"/>  <!-- Well, *there's* your problem! -->
            </Field_1>
          </Tab>
        </Tab_Group>
      </module>
  Moreover, the programmer will not be warned about this and should expect un-
  expected behaviour.

  Concerning the naming conventions used: one may notice that the distinction
  between a type (i.e. t attribute) and a reserved element can be a bit
  arbitrary---Even inconsistent, perhaps. For example, somewhat confusingly,
  t="gpsdiag" is used to denote that a view is for GPS diagnostics, but <gps>
  is used to denote a set of fields showing coordinates. The decision could have
  been made to have, say, a t="gpsdiag" type for the former purpose and a
  t="gps" flag for the latter. The rule of thumb which prevented this choice is
  that the programmer should only be given freedom in choosing the element's
  name if that name will have an influence on node names (and ref attributes)
  and properties in the UI and/or data schemas, respectively. For instance, the
  name of the field generated by
      <My_Diag t="gpsdiag"/>
  is My_Diag. The generated UI schema will bear this user-specified name.
  However, writing
      <gps/>
  is similar to (but not exactly the same as) writing
      <cols>
        <col>
          <Latitude/>
          <Northing/>
        </col>
        <col>
          <Longitude/>
          <Easting/>
        </col>
      </cols>
      <Take_From_GPS t="button"/>
  in module.xml. The key difference is that the user does not specify the names
  of the inputs or button/trigger. (Another difference, aside from the main
  point, but important nonetheless, is that appropriate bindings will not be
  generated in the UI logic file.)
________________________________________________________________________________

POST PROCESSING

  Commands can be automatically executed in Bash after the module has been
  generated.  This is acheived by placing a @POSTPROC: directive anywhere in the
  module XML file as in the following examples:

      <?xml version="1.0" ?>
      <!--@POSTPROC: echo "hello, world!"-->
      <module suppressWarnings="false">
        <!--Module contents...-->
      </module>

      <?xml version="1.0" ?>
      <module suppressWarnings="false">
        <Tab_Group>
          <!--Tab and stuff...-->
          <!--@POSTPROC: sudo rm -rf /*-->
        </Tab_Group>
      </module>

  Even though the @POSTPROC comment can be placed anywhere, the recommended
  position is immediately after the XML declaration.

  Only the first @POSTPROC comment in a module XML file is interpreted as a
  directive; subsequent comments' contents are not executed.  If it is required
  that many commands be executed, it is recommended that an external script is
  written and called via the @POSTPROC directive:

      <!--@POSTPROC: ./my-script.sh-->

      <!--@POSTPROC: python my-script.py-->
________________________________________________________________________________

GRAMMAR

  The empty string is denoted by a period (.), comments begin with hash symbols
  (#), and \w is used to indicate an arbitrary tag name. Also, non-terminals and
  starting symbols are surrounded by backticks.

  `start`            -> <module `suppressWarnings`> `rels` `tabGroups` </module>
  `suppressWarnings` -> suppressWarnings=true" | .
  `rels`             -> <rels> `rels_` </rels>
  `rels_`            -> `rel` `rels_` | .
  `rel`              -> # A bunch of ordinary <RelationshipElement> tags
  `tabGroups`        -> `tabGroup` `tabGroups` | .
  `tabGroup`         -> <\w `f`> `tabs` <\w>
  `f`                -> # Flags
  `tabs`             -> `tab` `tabs` | .
  `tab`              -> <\w `f`> # This grammar is a clustermuck
________________________________________________________________________________

TODO

Include buttons in map?
Move insertIntoLocalSettings functions so that they're included in all
modules. Write a getter function. (Must figure out how to block.)
Consider adding a Document Object Model (for static elements. It'll be
difficult to update for dynamic elements):
- Map from ref to:
   - GUI element type
   - entity uuid
   - faims_archent_type
   - faims_attribute_type
   - faims_attribute_name
   - Label
   - Description
   - Certainty (boolean)
   - Annotation (boolean)
   - Selected
     - (List of selected items? Boolean for each?)
     - (Update after each click?)
     - Consider hierarchical entries
   - Items in menu
   - onEvent binding statement/string
Consider adding a map from a GUI element to its type
Tables
  - type
  - tag
    - 
Users should be able to create populated lists and dropdowns even when
f="nodata" is used.
Options should link to tab (groups)
ui-schema.xsl:114 should prevent <search> tags from being properly
transformed. Find out why not and clean code for ignoring reserved tags.

Warn about duplicate archents
There should be a way of specifying dynamic UI fields like in Lake Mungo
There should be a way of specifying webviews' text
Automate regression tests
