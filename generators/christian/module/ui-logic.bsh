import android.util.Log;

Object dialog;         // Used to help coordinate the display of a "busy..." dialog
String parentTabgroup; // Used to allow entities to be saved as children

setFileSyncEnabled(true);
setSyncDelay(5.0f);
setSyncEnabled(true);
setSyncMaxInterval(600.0f);
setSyncMinInterval(5.0f);


makeLocalID(){
  fetchOne("CREATE TABLE IF NOT EXISTS localSettings (key text primary key, value text);", null);
  fetchOne("DROP VIEW IF EXISTS parentchild;", null);
  fetchOne("CREATE VIEW parentchild AS "+
           "SELECT parent.uuid as parentuuid, child.uuid as childuuid, parent.participatesverb as parentparticipatesverb, parent.relationshipid, parent.aenttypename as parentaenttypename, child.participatesverb as childparticipatesverb, child.aenttypename as childaenttypename "+
           "  FROM (SELECT uuid, participatesverb, aenttypename, relationshipid"+
           "          FROM latestnondeletedaentreln "+
           "          JOIN relationship USING (relationshipid) "+
           "          JOIN latestnondeletedarchent USING (uuid) "+
           "          JOIN aenttype USING (aenttypeid)) parent "+
           "  JOIN (SELECT uuid, relationshipid, participatesverb, aenttypename "+
           "          FROM latestnondeletedaentreln "+
           "          JOIN relationship USING (relationshipid) "+
           "          JOIN latestnondeletedarchent USING (uuid) "+
           "          JOIN aenttype USING (aenttypeid)) child "+
           "    ON (parent.relationshipid = child.relationshipid AND parent.uuid != child.uuid);", null);
}
makeLocalID();

newTab(String tab, Boolean resolveTabGroups) {
  if (!resolveTabGroups) {
    return newTab(tab);
  }

  tab = tab.replaceAll("/$", "");
  tab = tab.replaceAll("^/", "");
  if (tab.matches("/")) {
    newTab(tab);
  } else {
    newTabGroup(tab);
  }
}

/******************************************************************************/
/*                                 ACTION BAR                                 */
/******************************************************************************/
addActionBarItem("clean_synced_files", new ActionButtonCallback() {
  actionOnLabel() {
    "{Clean_Synced_Files}";
  }
  actionOn() {
    cleanSyncedFiles();
  }
});

addActionBarItem("sync", new ToggleActionButtonCallback() {
  actionOnLabel() {
    "{Disable_Sync}";
  }
  actionOn() {
    setSyncEnabled(false);
    setFileSyncEnabled(false);
    showToast("{Sync_Disabled}");
  }
  isActionOff() {
    isSyncEnabled();
  }
  actionOffLabel() {
    "{Enable_Sync}";
  }
  actionOff() {
    setSyncEnabled(true);
    setFileSyncEnabled(true);
    showToast("{Sync_Enabled}");
  }
});

addActionBarItem("internal_gps", new ToggleActionButtonCallback() {
  actionOnLabel() {
    "{Disable_Internal_GPS}";
  }
  actionOn() {
    stopGPS();
    showToast("{Internal_GPS_Disabled}");
    updateGPSDiagnostics();
  }
  isActionOff() {
    isInternalGPSOn();
  }
  actionOffLabel() {
    "{Enable_Internal_GPS}";
  }
  actionOff() {
    if(isExternalGPSOn()) {
      stopGPS();
    }
    startInternalGPS();
    showToast("{Internal_GPS_Enabled}");
    updateGPSDiagnostics();
  }
});

addActionBarItem("external_gps", new ToggleActionButtonCallback() {
  actionOnLabel() {
    "{Disable_External_GPS}";
  }
  actionOn() {
    stopGPS();
    if (isBluetoothConnected()) {
      showToast("{External_GPS_Disabled}");
    } else {
      showToast("{Please_Enable_Bluetooth}");
    }
    updateGPSDiagnostics();
  }
  isActionOff() {
    isExternalGPSOn();
  }
  actionOffLabel() {
    "{Enable_External_GPS}";
  }
  actionOff() {
    if(isInternalGPSOn()) {
      stopGPS();
    }
    startExternalGPS();
    if(isBluetoothConnected()) {
      showToast("{External_GPS_Enabled}");
    } else {
      showToast("{Please_Enable_Bluetooth}");
      this.actionOn();
    }
    updateGPSDiagnostics();
  }
});


/******************************************************************************/
/*                                    GPS                                     */
/******************************************************************************/
onEvent("Control/Main", "show", "updateGPSDiagnostics()");

updateGPSDiagnostics() {
  String diagnosticsRef = "Control/Main/GPS_Diagnostics";
  if (diagnosticsRef.equals("")) {
    return;
  }

  String status         = "";
  String previousStatus = getFieldValue(diagnosticsRef);
  String notInitialised = "{GPS_is_not_initialised}";

  // Check if GPS is initialised or was previously initialised.
  if (!isExternalGPSOn() && !isInternalGPSOn()) {
    if (!isNull(previousStatus) && !previousStatus.equals(notInitialised)) { // previous gps status is some last valid coordinate.
      // This is hackish. Arch16n substitution happens only at display-time, but the following if clause requires substitution to have happened at run-time
      String error = "";
      error = "{GPS_is_no_longer_initialised}. {Previous_status}:";
      setFieldValue(diagnosticsRef, error);   // Arch16n entry is substituted after this
      error = getFieldValue(diagnosticsRef);

      // check that error message wasn't previously appended to the previous status message.
      if (previousStatus.length()    >= error.length() &&
          previousStatus.subSequence(0, error.length()).equals(error)) {
        status = previousStatus;
      } else {
        status = error + "\n" + previousStatus;
      }
    } else {
      status = notInitialised;
    }
  } else {
    status += "{Internal_GPS}: ";
    if (isInternalGPSOn())
    {
      status += "{on}";
    } else {
      status += "{off}";
    }
    status += "\nExternal GPS: ";
    if (isExternalGPSOn())
    {
      if (isBluetoothConnected()) {
        status += "{on_and_bluetooth_connected}";
      } else {
        status += "{on_and_bluetooth_disconnected}";
      }
    } else {
      status += "{off}";
    }
    Object position = getGPSPosition();
    if (position != null) {
      Object projPosition = getGPSPositionProjected();
      status += "\n{Latitude}: " + position.getLatitude();
      status += "   {Longitude}: " + position.getLongitude();
      status += "\n{Northing}: " + projPosition.getLatitude();
      status += "   {Easting}: " + projPosition.getLongitude();
      status += "\n{Accuracy}: " + getGPSEstimatedAccuracy();
    } else {
      status += "\n{Position}: {no_GPS_position_could_be_found}";
    }
  }
  setFieldValue(diagnosticsRef, status);
}

/******************************************************************************/
/*                                 USER LOGIN                                 */
/******************************************************************************/

String userMenuPath = "User/User/Select_User";

populateListForUsers(){
  String getNonDeletedUsersQuery = "SELECT userid, fname || ' ' || lname "+
                                   "  FROM user "+
                                   " WHERE userdeleted is null;";

  fetchAll(getNonDeletedUsersQuery, new FetchCallback() {
    onFetch(result) {
      populateDropDown(userMenuPath, result, true);
    }
  });
}

String username = "";

selectUser () {
  String userVocabId  = getFieldValue(userMenuPath);
  String userQ        = "SELECT userid,fname,lname,email FROM user " +
                        "WHERE  userid='" + userVocabId + "';";
  FetchCallback callback = new FetchCallback() {
    onFetch(result) {
      user = new User(
            result.get(0),
            result.get(1),
            result.get(2),
            result.get(3)
      );
      setUser(user);
      username = result.get(1) + " " + result.get(2);
    }
  };

  fetchOne(userQ, callback);
}

onEvent(userMenuPath, "show",  "populateListForUsers()");
onEvent(userMenuPath, "select", "selectUser()");


/******************************************************************************/
/*                              MENU POPULATION                               */
/******************************************************************************/
/** Wrapper for to make a vocab without an exlusion list **/
makeVocab(String type, String path, String attrib) {
  makeVocab(type, path, attrib, null);
}

/** Vocab Population **/
/* Populates the path specified vocabulary from the database based on the given attribute name, where type 
is the type of the vocab to populate (PictureGallery, HierarchicalPictureGallery, CheckBoxGroup, DropDown, HierarchicalDropDown, RadioGroup or List). */
makeVocab(String type, String path, String attrib, List vocabExclusions) {
    makeVocab(type, path, attrib, vocabExclusions, null);
}

/* Populates the path specified vocabulary from the database based on the given attribute name, where type 
is the type of the vocab to populate (PictureGallery, HierarchicalPictureGallery, CheckBoxGroup, DropDown, HierarchicalDropDown, RadioGroup or List). */
makeVocab(String type, String path, String attrib, List vocabExclusions, String callbackFunction){
  if (isNull(type) || isNull(path) || isNull(attrib)) {
    Log.e("makeVocab()", "Can't make populate a vocab when the given type, path or attribute is Null");
    return;
  }

  if (type.equals("PictureGallery")) {
    String pictureGalleryQuery = "SELECT vocabid, vocabname, pictureurl "+
                                 "  FROM vocabulary "+
                                 "  LEFT OUTER JOIN attributekey USING (attributeid) "+
                                 " WHERE attributename = '" + attrib + "' "+
                                 " ORDER BY  vocabcountorder;";
    fetchAll(pictureGalleryQuery, new FetchCallback() {
      onFetch(pictures) {
        populatePictureGallery(path, pictures);
        if (callbackFunction != null && !isNull(callbackFunction)) {
          execute(callbackFunction);
        }
      }
    });
    return;
  }

  if (type.equals("HierarchicalPictureGallery")) {
    populateHierarchicalPictureGallery(path, attrib);
    if (callbackFunction != null && !isNull(callbackFunction)) {
      execute(callbackFunction);
    }
    return;
  }

  if (type.equals("HierarchicalDropDown")) {
    // populateHierarchicalDropDown(path, attrib);
    populateHierarchicalDropDown(path, attrib, true);
    if (callbackFunction != null && !isNull(callbackFunction)) {
      execute(callbackFunction);
    }
    return;
  }

  String getAttributeVocabQuery = "SELECT vocabid, vocabname "+
                                  "  FROM vocabulary "+
                                  "  JOIN attributekey USING (attributeid) "+
                                  " WHERE attributename = '" + attrib + "' "+
                                  " ORDER BY vocabcountorder;";
  fetchAll(getAttributeVocabQuery,
    new FetchCallback() {
      onFetch(result) {
        // print("makeVocab() result: " + result);
        if (result!=null && result.size()>0 && vocabExclusions!=null && vocabExclusions.size()>0) {
          List filteredVocab = new ArrayList();
          for(item : result) {
            if (vocabExclusions.contains(item.get(1))) {
              Log.d("makeVocab()", "removing vocab exclusion: " + item.get(1));
            } else {
              filteredVocab.add(item);
            }
          }
          result=filteredVocab;
        }
        // print("makeVocab() filtered result: " + result);
        if(type.equals("CheckBoxGroup")) {
          populateCheckBoxGroup(path, result);
        } else if(type.equals("DropDown")) {
          // populateDropDown(path, result);
          populateDropDown(path, result, true);
        } else if(type.equals("RadioGroup")) {
          populateRadioGroup(path, result);
        } else if(type.equals("List")) {
          populateList(path, result);
        }
        if (callbackFunction != null && !isNull(callbackFunction)) {
          execute(callbackFunction);
        }
      }
    });
}
makeVocab("RadioGroup", "Interview/Interview/Private", "Private");
makeVocab("DropDown", "Interview/Interview/Linguistic_Data_Type", "Linguistic Data Type");
makeVocab("DropDown", "Interview/Interview/Discourse_Type", "Discourse Type");
makeVocab("DropDown", "Interview/Interview/Linguistic_Subject", "Linguistic Subject");
makeVocab("DropDown", "Interview/Interview/Country", "Country");
makeVocab("DropDown", "Interview/Interview/Region_Villiage", "Region Villiage");
makeVocab("DropDown", "Interview/Interview/Language_Local_Name", "Language Local Name");
makeVocab("DropDown", "Interview/Interview/Language_Content_ISO639-3", "Language Content ISO639-3");
makeVocab("DropDown", "Interview/Interview/Language_Subject_ISO639-3", "Language Subject ISO639-3");
makeVocab("DropDown", "Agent_Role/Agent_Role/Role", "Role");


/******************************************************************************/
/*                                 VALIDATION                                 */
/******************************************************************************/
/* `ref`  is a reference/path to a field
 * `name` is a human-readable name for that field
 * `cond` is a String containing a boolean expression that evaluates to true if
 *        and only if the the field pair returned by this function should be
 *        validated.
 *
 *  Returns a field pair (really just an ArrayList).
 */
fieldPair(String ref, String name, String cond) {
  List fp = new ArrayList();
  fp.add(ref);
  fp.add(name);
  fp.add(cond);
  return fp;
}

fieldPair(String ref, String name) {
  String t = "true";
  return fieldPair(ref, name, t);
}

/* Returns true if field specified by `ref` is valid. False otherwise.
 */
isValidField(String ref) {
  return !isNull(getFieldValue(ref));
}
/* `format` can either be HTML or PLAINTEXT
 */
validateFields(List fields, String format) {
  Integer numInvalid = 0;

  /* Build validation message string (and count how many invalid fields exist) */
  String out = "Please fill out the following fields:\n";
  for(f : fields) {
    String ref  = f.get(0); // Reference to field
    String name = f.get(1); // Human-readable name
    String cond = f.get(2); // Validation condition

    // Only validate a field whose validation condition evaluates to `true`
    Boolean doValidateField = (Boolean) eval(cond);
    if (!doValidateField)
      continue;

    // Add any invalid fields to the output and tally them
    if (!isValidField(ref)) {
      out += "- " + name + "\n";
      numInvalid++;
    }
  }
  // All the fields are valid; just overwrite `out` with a cheery message
  if (numInvalid == 0)
    out = "All fields contain valid data!";

  /* Format the output as dictated by `format` */
  if (format == "HTML") {
    out = out.replace("\n", "<br>");
  } else if (format == "PLAINTEXT") {
    ;
  }

  return out;
}

validateInterview() {
  List f = new ArrayList(); // Fields to be validated

  f.add(fieldPair("Interview/Interview/Title", "{Title}"));
  f.add(fieldPair("Interview/Interview/Description", "{Description}"));
  f.add(fieldPair("Interview/Interview/Private", "{Private}"));
  f.add(fieldPair("Interview/Interview/Origination_Date", "{Origination_Date}"));
  f.add(fieldPair("Interview/Interview/Country", "{Country}"));

  String validationMessage = validateFields(f, "PLAINTEXT");
  showWarning("Validation Results", validationMessage);
}

/******************************************************************************/
/*                                 AUTOSAVING                                 */
/******************************************************************************/
Map tabgroupToUuid = new HashMap();

getUuid(String tabgroup) {
  tabgroupToUuid.get(tabgroup);
}

setUuid(String tabgroup, String uuid) {
  tabgroupToUuid.put(tabgroup, uuid);
}

saveTabGroup(String tabgroup) {
  saveTabGroup(tabgroup, "");
}

saveTabGroup(String tabgroup, String callback) {
  Boolean enableAutosave  = true;
  String  id              = getUuid(tabgroup);
  List    geometry        = null;
  List    attributes      = null;
  String  parentTabgroup_ = parentTabgroup;

  parentTabgroup = null;
  SaveCallback saveCallback  = new SaveCallback() {
    onSave(uuid, newRecord) {
      setUuid(tabgroup, uuid);
      populateAuthorAndTimestamp(tabgroup);
      if (newRecord && !isNull(parentTabgroup_)) {
        saveEntitiesToRel("Parent Of", getUuid(parentTabgroup_), uuid);
      }
      execute(callback);
    }
    onError(message) {
      showToast(message);
    }
  };

  populateAuthorAndTimestamp(tabgroup);
  saveTabGroup(tabgroup, id, geometry, attributes, saveCallback, enableAutosave);
}

populateAuthorAndTimestamp(String tabgroup) {
  Map tabgroupToAuthor    = new HashMap();
  Map tabgroupToTimestamp = new HashMap();

  String uuid          = getUuid(tabgroup);
  String authorPath    = tabgroupToAuthor.get(tabgroup);
  String timestampPath = tabgroupToTimestamp.get(tabgroup);
  if (isNull(uuid)) {
    if (!isNull(authorPath))
      setFieldValue(authorPath,    "Entity not yet saved");
    if (!isNull(timestampPath))
      setFieldValue(timestampPath, "Entity not yet saved");
    return;
  }

  String q = "SELECT createdat, createdby " +
             "  FROM createdmodifiedatby " +
             " WHERE uuid = '" + uuid + "'";
  FetchCallback callback = new FetchCallback() {
    onFetch(result) {
      if (!isNull(timestampPath))
        setFieldValue(timestampPath, result.get(0));
      if (!isNull(authorPath))
        setFieldValue(authorPath,    result.get(1));
    }
  };

  fetchOne(q, callback);
}

onShowInterview () {
  // TODO: Add some things which should happen when this tab group is shown
  saveTabGroup("Interview");
}
onShowAgentRole () {
  // TODO: Add some things which should happen when this tab group is shown
  saveTabGroup("Agent_Role");
}

onEvent("Interview", "show", "onShowInterview()");
onEvent("Agent_Role", "show", "onShowAgentRole()");

onClickUserLogin () {
  // TODO: Add some things which should happen when this element is clicked
  newTab("Control", true);
}
onClickControlRecordInterview () {
  // TODO: Add some things which should happen when this element is clicked
  newInterview();
}
onClickInterviewAddAgentRole () {
  // TODO: Add some things which should happen when this element is clicked
  String tabgroup = "Interview";
  if (isNull(getUuid(tabgroup))){
    showToast("{You_must_save_this_tabgroup_first}");
    return;
  }
  parentTabgroup = tabgroup;
  newAgentRole();
}

onEvent("User/User/Login", "click", "onClickUserLogin()");
onEvent("Control/Main/Record_Interview", "click", "onClickControlRecordInterview()");
onEvent("Interview/Interview/Add_Agent_Role", "click", "onClickInterviewAddAgentRole()");


/******************************************************************************/
/*                   AUDIO, CAMERA, FILE AND VIDEO BINDINGS                   */
/******************************************************************************/
onEvent("Interview/Interview/Button_Attached_Audio", "click", "attachAudioTo(\"Interview/Interview/Attached_Audio\")");
onEvent("Interview/Interview/Button_Attached_Video", "click", "attachVideoTo(\"Interview/Interview/Attached_Video\")");

/******************************************************************************/
/*                             NAVIGATION DRAWER                              */
/******************************************************************************/
removeNavigationButtons() {
  removeNavigationButton("new");
  removeNavigationButton("duplicate");
  removeNavigationButton("delete");
  removeNavigationButton("validate");
}

addNavigationButtons(String tabgroup) {
  removeNavigationButtons();

  addNavigationButton("new", new ActionButtonCallback() {
    actionOnLabel() {
      "{New}";
    }
    actionOn() {
      if(!isNull(getUuid(tabgroup))) {
          newRecord(tabgroup);
          showToast("{New_record_created}");
      } else {
          showAlert("{Warning}", "{Any_unsaved_changes_will_be_lost}", "newRecord(\""+tabgroup+"\")", "");
      }
    }
  }, "success");
  addNavigationButton("duplicate", new ActionButtonCallback() {
    actionOnLabel() {
      "{Duplicate}";
    }
    actionOn() {
      if(!isNull(getUuid(tabgroup))) {
          duplicateRecord(tabgroup);
      } else {
          showWarning("{Warning}", "{This_record_is_unsaved_and_cannot_be_duplicated}");
      }
    }
  }, "primary");
  addNavigationButton("delete", new ActionButtonCallback() {
    actionOnLabel() {
      "{Delete}";
    }
    actionOn() {
      deleteRecord(tabgroup);
    }
  }, "danger");
  addNavigationButton("validate", new ActionButtonCallback() {
    actionOnLabel() {
      "{Validate}";
    }
    actionOn() {
      String validationFunction = "validate" + tabgroup.replaceAll("_", "") + "()";
      eval(validationFunction);
    }
  }, "default");
}

/******************************************************************************/
/*        ENTITY AND RELATIONSHIP SAVING AND LOADING HELPER FUNCTIONS         */
/******************************************************************************/
/** Saves two entity id's as a relation. **/
saveEntitiesToRel(String type, String entity1, String entity2) {
    String callback = null;
    saveEntitiesToRel(type, entity1, entity2, callback);
}

/** Saves two entity id's as a relation with some callback executed. **/
saveEntitiesToRel(String type, String entity1, String entity2, String callback) {
    String e1verb = null;
    String e2verb = null;
    saveEntitiesToHierRel(type, entity1, entity2, e1verb, e2verb, callback);
}

/** Saves two entity id's as a hierachical relation with some callback executed. **/
saveEntitiesToHierRel(String type, String entity1, String entity2, String e1verb, String e2verb, String callback) {
    if (isNull(entity1) || isNull(entity2)) return;
    saveRel(null, type, null, null, new SaveCallback() {
        onSave(rel_id, newRecord) {
            addReln(entity1, rel_id, e1verb);
            addReln(entity2, rel_id, e2verb);
            if(!isNull(callback)) {
               execute(callback);
            }
        }
        onError(message) {
            Log.e("saveEntitiesToHierRel", message);
            showToast(message);
        }
    });
}

// Makes a new record of the given tabgroup
newRecord(String tabgroup) {
  cancelTabGroup(tabgroup, false);

  String newTabGroupFunction = "new" + tabgroup.replaceAll("_", "") + "()"; // Typical value: "newTabgroup()"
  eval(newTabGroupFunction);

  Log.d("newRecord", tabgroup);
}

// Deletes the current record of the given tabgroup
deleteRecord(String tabgroup) {
  String deleteTabGroupFunction = "delete" + tabgroup.replaceAll("_", "") + "()"; // Typical value: "deleteTabgroup()"
  eval(deleteTabGroupFunction);

  Log.d("deleteRecord", tabgroup);
}

// Duplicates the current record of the given tabgroup
duplicateRecord(String tabgroup) {
  dialog = showBusy("Duplicating", "Please wait...");

  String duplicateTabGroupFunction = "duplicate" + tabgroup.replaceAll("_", "") + "()"; // Typical value: "duplicateTabgroup()"
  eval(duplicateTabGroupFunction);

  Log.d("duplicateRecord", tabgroup);
}

// generic fetch saved attributes query
getDuplicateAttributeQuery(String originalRecordID, String attributesToDupe) {
  if (attributesToDupe.equals("")) {
    attributesToDupe = "''";
  }
  String duplicateQuery = "SELECT attributename, freetext, vocabid, measure, certainty " +
                          "  FROM latestnondeletedaentvalue JOIN attributekey USING (attributeid) " +
                          " WHERE attributename IN ('', "+attributesToDupe+") " +
                          "   AND uuid = '"+originalRecordID+"'; ";
  return duplicateQuery;
}

getDuplicateRelnQuery(String originalRecordID) {
  String dupeRelnQuery = "SELECT relntypename, parentparticipatesverb, childparticipatesverb, childuuid "+
                         "  FROM parentchild join relationship using (relationshipid) "+
                         "  JOIN relntype using (relntypeid) "+
                         " WHERE parentuuid = '"+originalRecordID+"';";
  return dupeRelnQuery;
}

makeDuplicateRelationships(fetchedAttributes, String newuuid){
  for (savedAttribute : fetchedAttributes){
    //  saveEntitiesToHierRel(relnname, parent, child, parentverb, childverb, relSaveCallback);
    //relntypename, parentparticipatesverb, childparticipatesverb, childuuid
    saveEntitiesToHierRel(savedAttribute.get(0), newuuid, savedAttribute.get(3), savedAttribute.get(1), savedAttribute.get(2), null);
  }
}

// generic get extra attributes
getExtraAttributes(fetchedAttributes) {
  List extraAttributes = createAttributeList();
  Log.d("Module", "Duplicating fetched attributes: " + fetchedAttributes.toString());
  for (savedAttribute : fetchedAttributes) {
    extraAttributes.add(
      createEntityAttribute(
        savedAttribute.get(0),
        savedAttribute.get(1),
        savedAttribute.get(2),
        savedAttribute.get(3),
        savedAttribute.get(4)
      )
    );
  }
  return extraAttributes;
}

loadEntity() {
  loadEntityFrom(getListItemValue());
}

loadEntityFrom(String entityID) {
  if (isNull(entityID)) {
    Log.e("Module", "Cannot load an entity with a null ID.");
    return;
  }

  String getEntTypeNameQ = "SELECT aenttypename " +
                           "  FROM latestnondeletedarchent " +
                           "  JOIN aenttype " +
                           " USING (aenttypeid) " +
                           " WHERE uuid = '" + entityID + "'";
  fetchAll(getEntTypeNameQ, new FetchCallback() {
    onFetch(result) {
      String archEntName = result.get(0).get(0);
      String loadFunction = "load" + archEntName.replaceAll(" ", "") + "From(entityID)"; // Typical value: loadContextFrom(entityID)
      eval(loadFunction);
    }
  });
}

newInterview(){
  String tabgroup = "Interview";


  setUuid(tabgroup, null);
  newTabGroup(tabgroup);

}

duplicateInterview(){
  String tabgroup = "Interview";

  disableAutoSave(tabgroup);


  populateFileList("Interview/Interview/Attached_Audio", new ArrayList());
  populateVideoGallery("Interview/Interview/Attached_Video", new ArrayList());


  saveCallback = new SaveCallback() {
    onSave(uuid, newRecord) {
      setUuid(tabgroup, uuid);
      populateAuthorAndTimestamp(tabgroup);

      Boolean enable_autosave = true;

      fetchAll(getDuplicateRelnQuery(getUuid(tabgroup)), new FetchCallback(){
        onFetch(result) {
          makeDuplicateRelationships(result, getUuid(tabgroup));
          showToast("{Duplicated_record}");
          dialog.dismiss();
        }
      });

      saveTabGroup(tabgroup, getUuid(tabgroup), null, null, new SaveCallback(){
        onSave(autosaveUuid, autosaveNewRecord) {
          setUuid(tabgroup, autosaveUuid);
        }
      }, enable_autosave);
    }
  };

  String extraDupeAttributes = "";
  fetchAll(getDuplicateAttributeQuery(getUuid(tabgroup), extraDupeAttributes), new FetchCallback(){
    onFetch(result) {
      excludeAttributes = new ArrayList();
      excludeAttributes.add("Attached Audio");
      excludeAttributes.add("Attached Video");

      duplicateTabGroup(tabgroup, null, getExtraAttributes(result), excludeAttributes, saveCallback);
    }
  });
}

deleteInterview(){
  String tabgroup = "Interview";

  if (isNull(getUuid(tabgroup))) {
    cancelTabGroup(tabgroup, true);
  } else {
    showAlert("{Confirm_Deletion}", "{Press_OK_to_Delete_this_Record}", "reallyDeleteInterview()", "doNotDelete()");
  }
}

reallyDeleteInterview(){
  String tabgroup = "Interview";
  deleteArchEnt(getUuid(tabgroup));
  cancelTabGroup(tabgroup, false);
}

newAgentRole(){
  String tabgroup = "Agent_Role";


  setUuid(tabgroup, null);
  newTabGroup(tabgroup);

}

duplicateAgentRole(){
  String tabgroup = "Agent_Role";

  disableAutoSave(tabgroup);




  saveCallback = new SaveCallback() {
    onSave(uuid, newRecord) {
      setUuid(tabgroup, uuid);
      populateAuthorAndTimestamp(tabgroup);

      Boolean enable_autosave = true;

      fetchAll(getDuplicateRelnQuery(getUuid(tabgroup)), new FetchCallback(){
        onFetch(result) {
          makeDuplicateRelationships(result, getUuid(tabgroup));
          showToast("{Duplicated_record}");
          dialog.dismiss();
        }
      });

      saveTabGroup(tabgroup, getUuid(tabgroup), null, null, new SaveCallback(){
        onSave(autosaveUuid, autosaveNewRecord) {
          setUuid(tabgroup, autosaveUuid);
        }
      }, enable_autosave);
    }
  };

  String extraDupeAttributes = "";
  fetchAll(getDuplicateAttributeQuery(getUuid(tabgroup), extraDupeAttributes), new FetchCallback(){
    onFetch(result) {
      excludeAttributes = new ArrayList();

      duplicateTabGroup(tabgroup, null, getExtraAttributes(result), excludeAttributes, saveCallback);
    }
  });
}

deleteAgentRole(){
  String tabgroup = "Agent_Role";

  if (isNull(getUuid(tabgroup))) {
    cancelTabGroup(tabgroup, true);
  } else {
    showAlert("{Confirm_Deletion}", "{Press_OK_to_Delete_this_Record}", "reallyDeleteAgentRole()", "doNotDelete()");
  }
}

reallyDeleteAgentRole(){
  String tabgroup = "Agent_Role";
  deleteArchEnt(getUuid(tabgroup));
  cancelTabGroup(tabgroup, false);
}


doNotDelete(){
  showToast("{Delete_Cancelled}");
}
onEvent("User", "show", "removeNavigationButtons()");
onEvent("Control", "show", "removeNavigationButtons()");
onEvent("Interview", "show", "addNavigationButtons(\"Interview\")");
onEvent("Agent_Role", "show", "addNavigationButtons(\"Agent_Role\")");

/******************************************************************************/
/*                                   SEARCH                                   */
/******************************************************************************/
onEvent("Control/Search"               , "show"  , "search();");
onEvent("Control/Search/Entity_List"   , "click" , "loadEntity();");
onEvent("Control/Search/Search_Button" , "click" , "search()");
onEvent("Control/Search/Search_Term"   , "click" , "clearSearch()");
onEvent("Control/Search/Entity_Types"  , "click" , "search()");

entityTypes = new ArrayList();
entityTypes.add(new NameValuePair("{All}", ""));
entityTypes.add(new NameValuePair("{Interview}", "Interview"));
entityTypes.add(new NameValuePair("{Agent_Role}", "Agent Role"));
populateDropDown("Control/Search/Entity_Types", entityTypes);

clearSearch(){
  setFieldValue("Control/Search/Search_Term","");
}

search(){
  String tabgroup = "Control";
  String refEntityList  = tabgroup + "/Search/Entity_List";
  String refSearchTerm  = tabgroup + "/Search/Search_Term";
  String refEntityTypes = tabgroup + "/Search/Entity_Types";

  String type = getFieldValue(refEntityTypes);
  String term = getFieldValue(refSearchTerm);
  String searchQuery = "SELECT uuid, response "+
                       "  FROM latestNonDeletedArchEntFormattedIdentifiers  "+
                       " WHERE uuid in (SELECT uuid "+
                       "                  FROM latestNonDeletedArchEntIdentifiers "+
                       "                 WHERE measure LIKE '"+term+"'||'%'  "+
                       "                   AND ( aenttypename LIKE '"+type+"' OR '' = '"+type+"' ) "+
                       "                )  "+
                       " ORDER BY response "+
                       " LIMIT ? "+
                       "OFFSET ? ";

  populateCursorList(refEntityList, searchQuery, 25);
  refreshTabgroupCSS(tabgroup);

  Log.d("Module", "Search query: " + searchQuery);
}

loadInterviewFrom(String uuid) {
  String tabgroup = "Interview";
  setUuid(tabgroup, uuid);
  if (isNull(uuid)) return;

  showTabGroup(tabgroup, uuid);
}

loadAgentRoleFrom(String uuid) {
  String tabgroup = "Agent_Role";
  setUuid(tabgroup, uuid);
  if (isNull(uuid)) return;

  showTabGroup(tabgroup, uuid);
}


/******************************************************************************/
/*                POPULATION OF ENTITY AND CHILD ENTITY LISTS                 */
/******************************************************************************/
/*
 * `viewType`   the type of GUI element to be populated. It can either equal
 *              "DropDown" or "List".
 * `path`       the reference of the GUI element to be populated.
 * `parentUuid` the parent in the relationship denoted by `relType`.
 * `entType`    the type of the entities the menu will be populated with.
 * `relType`    the name of the relationship the children are to be in with the
 *              entity denoted by `parentUuid`.
 */
populateMenuWithEntities (
  String viewType,
  String path,
  String parentUuid,
  String entType,
  String relType
) {
  if (isNull(parentUuid))
    return;

  String getChildEntitiesQ = "" +
    "SELECT childuuid, response "+
    "  FROM parentchild JOIN latestNonDeletedArchEntFormattedIdentifiers ON (childuuid = uuid) " +
    "  JOIN createdmodifiedatby USING (uuid) " +
    " WHERE relationshipid IN (SELECT relationshipid  " +
    "                            FROM latestnondeletedrelationship JOIN relntype USING (relntypeid) " +
    "                           WHERE relntypename = '"+relType+"') " +
    "   AND parentuuid = " + parentUuid + " " +
    "   AND (childaenttypename = '"+entType+"' OR '"+entType+"' = '') " +
    " ORDER BY createdat DESC ";

  String getEntitiesQ = "" +
    "SELECT uuid, response "+
    "  FROM latestNonDeletedArchEntFormattedIdentifiers  "+
    " WHERE uuid in (SELECT uuid "+
    "                  FROM latestNonDeletedArchEntIdentifiers "+
    "                 WHERE aenttypename = '"+entType+"' OR '"+entType+"' = '' " +
    "               )  "+
    " ORDER BY response ";

  String q = null;
  if (relType.equals("")) {
    q = getEntitiesQ;
  } else {
    q = getChildEntitiesQ;
  }

  FetchCallback cbPopulateDropDown = new FetchCallback() {
    onFetch(result) {
      populateDropDown(path, result);
    }
  };

  switch (viewType) {
    case "DropDown":
      fetchAll(q, cbPopulateDropDown);
      break;
    case "List":
      q += " LIMIT ? OFFSET ? ";
      populateCursorList(path, q, 25);
      break;
    default:
      Log.e("populateMenuWithEntities ", "Unexpected type '" + viewType + "'");
  }
}

menus = new ArrayList();
menus.add(new String[] {
  "DropDown",
  "Interview/Interview/List_of_Agent_Roles",
  "getUuid(\"Interview\")",
  "Agent Role",
  "Parent Of"
});
for (m : menus) {
  String viewType       = m[0];
  String path           = m[1];
  String parentUuidCall = m[2];
  String entType        = m[3];
  String relType        = m[4];

  String functionCall = "";
  functionCall += "populateMenuWithEntities(";
  functionCall += "\"" + viewType       + "\"";
  functionCall += ", ";
  functionCall += "\"" + path           + "\"";
  functionCall += ", ";
  functionCall +=        parentUuidCall       ;
  functionCall += ", ";
  functionCall += "\"" + entType        + "\"";
  functionCall += ", ";
  functionCall += "\"" + relType        + "\"";
  functionCall += ")";

  onEvent(path, "show", functionCall);
}
